
## Inline authorisation

In the example app it is possible to edit a job even if you are not signed in.  To stop this in the JobController, edit function we can easily stop this with the following in line check.

![[Pasted image 20240923163900.png]]

This basically forces a guest or user who has NOT been authorised yet to login.

Just because a user is signed in they should not be allowed to edit a job they did not create or are not responsible for.

We can check this as follows.  
![[Pasted image 20240923182401.png]]

The above is basically saying if the current "Authorised User" isNot the same as the user who belongs to the employer who owns the job then abort displaying 403 FORBIDDEN.

All this is possible because of the DB relationships that have been put in place in DB migrations and then in the models the following functions have been added.
![[Pasted image 20240923183118.png]]
The above Job model has the function employer() which states the Job belongs to an Employer.

![[Pasted image 20240923182922.png]]

The above Employer model has the function user which states the Employer belongs to a User.  Or think of it like this $this(employer) belongs to a User.



In the DB we have Employers who belong to a User notice the user_id.
![[Pasted image 20240923181928.png]]

The User creates Jobs that belong to an Employer.
![[Pasted image 20240923182109.png]]

The User with the id 55 is 
![[Pasted image 20240923182211.png]]

If we login as this user using the a password of "password" we should now be able to edit this one job but not the others.

## Gates
The above is all well and good in that yes it will stop an unauthorised user editing the selected job.  However, the UI still shows the Edit button and this really isn't the desired approach.  The problem is the logic which controllers the authorisation is stuck inside the controller. 

This is where Gates can help.

Gates are barriers if you are authorised the gate will open.



